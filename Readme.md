## Up 场景说明

利用 Opengl 实现一个 3D 场景，综合所学知识完成一个场景。看过几部电影，对天空之城和飞屋环游记比较深刻，所以打算实现一个天空的场景。实现结果如下。

### 白天

![1546406581382](C:\Users\22482\AppData\Roaming\Typora\typora-user-images\1546406581382.png)

### 黑夜

![1546412421647](C:\Users\22482\AppData\Roaming\Typora\typora-user-images\1546412421647.png)

可以看见场景中有如下几个实现

1. 热气球。灵感来自飞屋环游记，一部很好看的动漫电影。
2. 小狗。为了不让机器人太孤单。
3. 房屋。OBJ文件，导入进行放缩平移得到的结果。
4. 圣诞树。这几天过节，加个圣诞树调节氛围。
5. 机器人，基于层次建模实现的简单机器人，可以沿着X或者Z轴移动，当然不能飞，所以不能沿着Y轴移动
6. 灯光。点光源，这样照过去就能看见小阳台。
7. 阴影。阴影利用深度纹理帧缓存实现。不是影阴影。

交互如下：

1. 前后左右控制机器人方向
2.  q 、e 控制白天黑夜
3.  m 控制飞行模式还是行走模式
4.  wads 控制相机位置
5.  鼠标移动控制相机的欧拉角
6. 滚轮控制相机的视野

## 实验环境

1. 使用 VS2017 在 release 和 X86 模式下运行

2. 使用以下库，利用 Cmake 编译成 X86 的 release 模式的。

   - GLFW 库：专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。
   - GLAD 库：基于Core的3.3版本、C++语言（在线生成要保证生成加载器）
   - stb_image 库：用来读取纹理图片
   - glm 数学矩阵库：0.9.9版本（此时默认初始化为全0矩阵）
   - assimp 库：3.3.1版本，用来读取obj文件


## 参考资源

1. 教程：https://learnopengl.com/
2. 天空图：http://www.custommapmakers.org/skyboxes.php
3. OBJ文件：https://clara.io/library，https://free3d.com/3d-models/obj

## 场景实现要求

1. 多个虚拟物体组成一个虚拟场景，场景可以是室内或者室外场景；场景应包含地面。

2. 给至少两个物体添加纹理贴图

3. 添加光照、阴影效果

4. 用户交互实现视角切换完成对场景的任意角度浏览

5. 通过交互控制物体

   实现物体的变换，允许用户通过键盘或者鼠标实现场景中至少两个物体的控制（移动，旋转，缩放等等）。

### 1. 背景（纹理实现）

背景是通过正方体贴图实现，Oepngl提供了正方体贴图函数。所以我们将贴图实现封装成了一个类，其中变量包括VAO、VBO以及textureID，还有就是顶点坐标以及6张图片路径。

大概步骤如下

1. 申请VAO和VBO，将顶点数据传给VBO。
2. 申请纹理对象，传给GPU，这时绑定参数是GL_TEXTURE_CUBE_MAP，这样可以快速绑定6个面。
3. 编写相应的着色器对其进行渲染即可

天空图的资源是tga格式的六张图片

![1546407607385](C:\Users\22482\AppData\Roaming\Typora\typora-user-images\1546407607385.png)

天空图的纹理坐标其实和正方体的纹理坐标一样，所以天空图的位置信息就是纹理信息，天空图不需要法向量。常规操作将位置坐标的数据传入GPU

![1546407716660](C:\Users\22482\AppData\Roaming\Typora\typora-user-images\1546407716660.png)

利用循环将纹理下载并存到GPU中

![1546407826466](C:\Users\22482\AppData\Roaming\Typora\typora-user-images\1546407826466.png)

最后渲染的时候绑定正方体贴图即可。

### 2. 光照

本人实现的光照是基于冯氏光照的实现，主要的实现在于片元着色器中的实现。由于我写了多个着色器，有几个片元着色器都有光照处理，所以这里我打算将模型导入后的光照处理，实现在着色器 model.fs 中。

先看一下我着色器中需要用到的数据，如下

![1546409138720](C:\Users\22482\AppData\Roaming\Typora\typora-user-images\1546409138720.png)



光照会涉及到以下几个方面。

1. 灯光的材质

   包括灯光位置、环境反射系数、漫反射系数、镜面反射系数

2. 模型的材质

   片元高光系数、片元的法向量、以及片元的漫反射纹理。

3. ratio 是天空的太阳光系数。

4. viewPos 是眼睛的位置，因为镜面反射光是射向眼睛的，所以这里需要眼睛的位置。

核心实现代码如下

![1546410015874](C:\Users\22482\AppData\Roaming\Typora\typora-user-images\1546410015874.png)

1. 环境光的实现是漫反射贴图。系数取自灯光的漫反射系数和太阳光系数。

2. 漫反射需要片元法向量，光线方向，漫反射就是光线在法向上的投影内积。
3. 镜面反射需要得到反射光线在视线上的投影，以及高亮系数的配置

### 3. 阴影 

阴影实现不是利用阴影矩阵实现的，而是利用深度纹理实现。之前学过深度检测，在不同的视图有不同的深度信息，所以如果我们在光照的视图下将深度存储起来，然后在缓存的时候再进行使用，这样就可以和深度纹理进行对比，如果光照照不到，就产生阴影，如果找得到，进行光照。这里涉及到的知识点有

1. 深度纹理，利用纹理信息存储
2. 帧缓存，利用帧缓存将深度信息存储起来。

![1546411452152](C:\Users\22482\AppData\Roaming\Typora\typora-user-images\1546411452152.png)

将纹理在我们绑定到帧缓存中，进行相应的渲染。渲染之后，深度信息就会缓存到我们的位置上，然后再进行一次正常的光照渲染，不过这时候光照渲染的片元着色器中多了一个阴影处理

![1546411780889](C:\Users\22482\AppData\Roaming\Typora\typora-user-images\1546411780889.png)

其中 ShadowCalculation 是计算眼睛看到的场景中 片元是否在阴影中。如果在阴影中就进行光照调暗，调暗就是通过阴影系数 shadow。

### 4. 照相机

视角转换用的是 FPS 风格的摄像机模式。主要有以下几个变量

1. 视角的实现是利用欧拉角，主要是偏航角和俯仰角，YAW 是偏航角，PITCH 是俯仰角，通过鼠标的移动控制角度

![1546414857773](C:\Users\22482\AppData\Roaming\Typora\typora-user-images\1546414857773.png)

2. 相机坐标系， 功能正如下图注释所示

![1546415264768](C:\Users\22482\AppData\Roaming\Typora\typora-user-images\1546415264768.png)

相机实现

1. 相机的移动，通过WASD键交互

![1546415447985](C:\Users\22482\AppData\Roaming\Typora\typora-user-images\1546415447985.png)

判断相机的移动方向进行相应分量的加减。Camera_Movement 是一个枚举类型，判断相应的方向。

2. 鼠标的移动（相机方向的变换）

鼠标移动会有相应的偏移，偏移要乘以灵敏度，不然旋转太快了会有点晕。

![1546415692806](C:\Users\22482\AppData\Roaming\Typora\typora-user-images\1546415692806.png)

3. 根据欧拉角更新相机位置， 其实就是利用 sin 函数和 cos 函数将其角度转化为方向向量。

![1546416215658](C:\Users\22482\AppData\Roaming\Typora\typora-user-images\1546416215658.png)

### 5. 机器人层级建模

机器人跑动的时候，手和脚会跟着摆动，这是通过层级建模实现的。模型图片如下

![1546416711898](C:\Users\22482\AppData\Roaming\Typora\typora-user-images\1546416711898.png)

看上图可以发现，机器人有六个部件，分别是上下肢，头部和身体。所有东西都是基于身体的模型进行变换的，当人物移动的时候，手脚会有一个变量进行控制摆动。核心代码如下。

1. 主要模型矩阵

![1546417079312](C:\Users\22482\AppData\Roaming\Typora\typora-user-images\1546417079312.png)

以后的变换都是基于这个模型进行，在做了自己的变换之后，再对这个变换乘以主要的模型矩阵，就可以自由的变换了。

- 机器人其实是一个正方体进行六次变换得到的结果。我们看看右上肢的实现即可，其他变换类似。

![1546417743437](C:\Users\22482\AppData\Roaming\Typora\typora-user-images\1546417743437.png)

首先是图元实例化，然后平移到身体的相对位置，当然平移之前可以实现转动，转动的幅度用一个变量 robot_rotate 控制。